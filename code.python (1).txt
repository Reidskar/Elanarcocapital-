```python
"""
Bot Telegram avanzado para Xiaomi 14T Pro con integraciÃ³n total GPT-4 y Google Drive.

CaracterÃ­sticas ampliadas:
- SincronizaciÃ³n y clasificaciÃ³n automÃ¡tica de archivos por fecha, tipo, continente e importancia.
- ValidaciÃ³n exhaustiva de cada informaciÃ³n enviada con GPT-4 (solo se guarda info verificada).
- AcumulaciÃ³n histÃ³rica para seguimiento y continuidad con anÃ¡lisis de lÃ­nea temporal.
- Completo flujo de trabajo con comandos Telegram y botones inline orientados a UX mÃ³vil Xiaomi 14T Pro.
- Soporte multimedia (texto, links, imÃ¡genes, videos, archivos).
- Alarmas, recordatorios y notificaciones adaptadas para integraciÃ³n con Tasker (o apps Android similares).
- GeneraciÃ³n avanzada de informes Word con portada revista, Ã­ndice, secciones, anexos, formato limpio y coherente.
- GestiÃ³n segura y concurrente, con logs para detectar fallos y confirmar almacenamientos.
- Descarga, subida, renombrado y movimiento de archivos Drive desde el bot dinÃ¡micamente.
- Interfaz conversacional enriquecida, mensajes Markdown legibles, y gestiÃ³n inteligente de estado.
- GeneraciÃ³n de scripts para YouTube y creaciÃ³n automÃ¡tica de videos informativos.

Requisitos:
- pip install python-telegram-bot openai google-api-python-client google-auth-httplib2 google-auth-oauthlib python-docx pytz moviepy elevenlabs

Estructura y ejecuciÃ³n:
- Ejecuta este script en un entorno Python 3.9+ con librerÃ­as y credenciales configuradas.
- Configura webhook o polling para que el bot estÃ© disponible 24/7.
- Integra con Tasker vÃ­a comandos y notificaciones personalizadas para mÃ¡xima experiencia mÃ³vil.
"""

import os
import logging
import asyncio
import datetime
import json
from io import BytesIO
from typing import List, Dict, Optional

import pytz
import openai

from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.http import MediaIoBaseUpload, MediaFileUpload

from telegram import (
    Update, InputFile, ChatAction, InlineKeyboardMarkup, InlineKeyboardButton,
    ParseMode, MessageEntity
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes,
    CallbackQueryHandler, filters
)

from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT

from moviepy.editor import *
from elevenlabs import generate, set_api_key, voices, Voice, VoiceSettings

# --- CONFIG ---
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "7594745239:AAEWC7V2fXh36wCohPkr5WqqhOe75IB40DQ")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "sk-...")  # Inserta tu clave OpenAI real aquÃ­
GOOGLE_CREDENTIALS_FILE = 'credentials.json'
TOKEN_FILE = 'token.json'
ELEVENLABS_API_KEY = os.getenv("ELEVENLABS_API_KEY", "...")  # Inserta tu clave ElevenLabs real aquÃ­

ROOT_FOLDER_ID = "1XJtm-nLkI_ArAEwKv8iaG2VpPQIMXC8R"  # RAW
CLASSIFIED_FOLDER_ID = "15HhoZ3OjOWmUQ_xW6VY0WnZ6X57H4ov1"  # CLASSIFIED
REPORTS_FOLDER_ID = "171_S78635eoLHih3sL8k2djLsqlTuywB"  # INFORMES_DIARIOS
MASTER_PROMPT_FILE_ID = "1XJtm-nLkI_ArAEwKv8iaG2VpPQIMXC8R"

TIMEZONE = pytz.timezone('America/Santiago')
DAY_END_HOUR = 23
DAY_END_MINUTE = 30

logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)
openai.api_key = OPENAI_API_KEY
set_api_key(ELEVENLABS_API_KEY)

# --- Utilidades de fecha y hora ---
def now_in_tz():
    return datetime.datetime.now(tz=TIMEZONE)

def current_day(dt: datetime.datetime):
    cutoff = dt.replace(hour=DAY_END_HOUR, minute=DAY_END_MINUTE, second=0, microsecond=0)
    return (dt + datetime.timedelta(days=1)).date() if dt > cutoff else dt.date()

def date_str(date: datetime.date):
    return date.strftime('%Y-%m-%d')

def format_event_for_mobile(event: Dict) -> str:
    """Genera texto markdown legible, jerarquizado para lectura mÃ³vil fluida"""
    lines = []
    lines.append(f"*{event.get('summary', 'Sin resumen')}*")
    lines.append(f"_Continente_: {event.get('continent', 'ğŸŒ Desconocido')} | _Tipo_: {event.get('event_type', 'Desconocido')}")
    lines.append(f"â­ Importancia: {event.get('importance', 3)}/5")
    deaths = event.get('deaths')
    if deaths:
        lines.append(f"â˜ ï¸ Muertos: {deaths}")
    decl = event.get('declarations')
    if decl:
        lines.append(f"ğŸ’¬ Declaraciones: {decl}")
    links = event.get('links', [])
    if links:
        lines.append("ğŸ”— Links:")
        for link in links[:3]:
            lines.append(f"- {link}")
    analysis = event.get('analysis')
    if analysis:
        short_analysis = analysis if len(analysis) <= 300 else analysis[:297] + "..."
        lines.append(f"ğŸ“ AnÃ¡lisis: {short_analysis}")
    return "\n".join(lines)

# --- Google Drive Manager ---
class DriveManager:
    def __init__(self):
        self.creds = None
        self.service = None
        self.authenticate()

    def authenticate(self):
        if os.path.exists(TOKEN_FILE):
            self.creds = Credentials.from_authorized_user_file(TOKEN_FILE, ['https://www.googleapis.com/auth/drive'])
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(GOOGLE_CREDENTIALS_FILE, ['https://www.googleapis.com/auth/drive'])
                self.creds = flow.run_local_server(port=0)
            with open(TOKEN_FILE, 'w') as token:
                token.write(self.creds.to_json())
        self.service = build('drive', 'v3', credentials=self.creds)
        logger.info("Google Drive autenticado correctamente.")

    def find_folder(self, name: str, parent: str) -> Optional[str]:
        query = f"mimeType='application/vnd.google-apps.folder' and trashed=false and name='{name}' and '{parent}' in parents"
        res = self.service.files().list(q=query, fields='files(id)').execute()
        files = res.get('files', [])
        return files[0]['id'] if files else None

    def create_folder(self, name: str, parent: str) -> str:
        metadata = {'name': name, 'mimeType': 'application/vnd.google-apps.folder', 'parents': [parent]}
        folder = self.service.files().create(body=metadata, fields='id').execute()
        logger.info(f"Carpeta creada: {name} ({folder.get('id')})")
        return folder.get('id')

    def get_or_create_folder(self, name: str, parent: str) -> str:
        folder_id = self.find_folder(name, parent)
        if folder_id:
            return folder_id
        return self.create_folder(name, parent)

    def upload_bytes(self, folder_id: str, filename: str, content: bytes, mimetype: str) -> str:
        from googleapiclient.http import MediaIoBaseUpload
        fh = BytesIO(content)
        media = MediaIoBaseUpload(fh, mimetype=mimetype, resumable=True)
        metadata = {'name': filename, 'parents': [folder_id]}
        file = self.service.files().create(body=metadata, media_body=media, fields='id').execute()
        logger.info(f"Archivo '{filename}' subido a carpeta {folder_id}")
        return file['id']

    def move_file(self, file_id: str, folder_id: str, new_name: Optional[str] = None):
        body = {}
        if new_name:
            body['name'] = new_name
            self.service.files().update(fileId=file_id, body=body).execute()
        f = self.service.files().get(fileId=file_id, fields='parents').execute()
        previous_parents = ",".join(f.get('parents', []))
        self.service.files().update(fileId=file_id, addParents=folder_id, removeParents=previous_parents, fields='id, parents').execute()
        logger.info(f"Archivo {file_id} movido a {folder_id} y renombrado a {new_name}")

    def read_text_file(self, file_id: str) -> str:
        from googleapiclient.http import MediaIoBaseDownload
        request = self.service.files().get_media(fileId=file_id)
        fh = BytesIO()
        downloader = MediaIoBaseDownload(fh, request)
        done = False
        while not done:
    	    status, done = downloader.next_chunk()
        fh.seek(0)
        return fh.read().decode('utf-8')

    def get_master_prompt(self) -> str:
        try:
            prompt = self.read_text_file(MASTER_PROMPT_FILE_ID)
            logger.info("Prompt maestro cargado desde Drive.")
            return prompt
        except Exception as e:
            logger.warning(f"Error cargando prompt maestro: {e}")
            return ""

# --- Informe diario ---
class InformeDiario:
    def __init__(self, date: datetime.date, drive: DriveManager):
        self.date = date
        self.drive = drive
        self.events: List[Dict] = []
        self.historical_context: str = ""
        self.timeline_events: List[Dict] = []

    def add_event(self, event: Dict):
        self.events.append(event)
        logger.info(f"Evento agregado: {event.get('summary', '')[:20]}...")

    def load_historical_context(self):
        # Se puede extender para cargar informes y eventos histÃ³ricos
        self.historical_context = self.drive.get_master_prompt()

    def add_timeline(self, prior_events: List[Dict]):
        self.timeline_events = prior_events

    def generate_report_bytes(self) -> bytes:
        logger.info("Generando informe Word detallado...")
        doc = Document()

        # Portada estilo revista
        p = doc.add_paragraph()
        p.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        r = p.add_run("Elanarcocapital\n")
        r.font.size = Pt(48)
        r.bold = True
        doc.add_paragraph(f"Informe Diario - {self.date.strftime('%Y-%m-%d')}", style='Title')

        doc.add_page_break()

        # Contexto histÃ³rico
        doc.add_heading("Contexto HistÃ³rico", level=1)
        doc.add_paragraph(self.historical_context or "No disponible.")

        doc.add_page_break()

        # LÃ­nea de tiempo previa - resumen limitado
        if self.timeline_events:
            doc.add_heading("LÃ­nea de Tiempo Previa", level=1)
            for ev in self.timeline_events[-10:]:
                ts = ev.get('timestamp', '')
                summ = ev.get('summary', '')
                doc.add_paragraph(f"[{ts}] {summ}")

            doc.add_page_break()  

        # Eventos del dÃ­a
        doc.add_heading("Eventos del DÃ­a", level=1)
        for e in self.events:
            p = doc.add_paragraph()
            p.add_run(f"Resumen: {e.get('summary','')}\n").bold = True
            p.add_run(f"Continente: {e.get('continent', '')}\n")
            p.add_run(f"Tipo: {e.get('event_type', '')}\n")
            p.add_run(f"Importancia: {e.get('importance', '')}\n")
            p.add_run(f"Muertos: {e.get('deaths', '')}\n")
            if e.get('declarations'):
                p.add_run(f"Declaraciones: {e.get('declarations')}\n")
            if e.get('links'):
                p.add_run("Links:\n")
                for lnk in e.get('links', []):
                    p.add_run(f"- {lnk}\n")
            if e.get('analysis'):
                p.add_run(f"AnÃ¡lisis:\n{e.get('analysis')[:1000]}\n")

        bio = BytesIO()
        doc.save(bio)
        bio.seek(0)
        logger.info("Informe generado con Ã©xito.")
        return bio.read()

    async def generate_youtube_script(self) -> str:
        """Genera un script para YouTube usando GPT-4."""
        prompt = f"""
        Eres un experto en geopolÃ­tica y economÃ­a. Crea un script para un video de YouTube
        que resuma los eventos del dÃ­a {self.date.strftime('%Y-%m-%d')}.

        Incluye:
        - Una introducciÃ³n atractiva.
        - ResÃºmenes concisos de cada evento importante.
        - Un anÃ¡lisis general de las tendencias del dÃ­a.
        - Una conclusiÃ³n que invite a la reflexiÃ³n.

        Eventos del dÃ­a:
        """
        for e in self.events:
            prompt += f"- {e.get('summary','')}\n"

        messages = [{"role": "system", "content": "Eres un asistente experto en la creaciÃ³n de scripts para YouTube."},
                    {"role": "user", "content": prompt}]
        script = await openai_chat(messages, model="gpt-4", max_tokens=2000)
        logger.info("Script de YouTube generado con Ã©xito.")
        return script

    async def create_video(self) -> str:
        """Crea un video informativo usando los eventos del dÃ­a."""
        script = await self.generate_youtube_script()
        audio_file = await self.generate_audio(script)
        video_file = await self.generate_video_from_events(audio_file)
        logger.info("Video generado con Ã©xito.")
        return video_file

    async def generate_audio(self, script: str) -> str:
        """Genera un archivo de audio usando ElevenLabs."""
        try:
            voice = Voice(
                voice_id="pNInz6obpgDQGcfVFhuJ",  # ID de la voz de Rachel
                settings=VoiceSettings(stability=0.71, similarity_boost=0.5, style=0.0, use_speaker_boost=True)
            )

            audio = generate(
                text=script,
                voice=voice,
                model="eleven_monolingual_v1"
            )
            audio_file = f"audio_{self.date.strftime('%Y-%m-%d')}.mp3"
            with open(audio_file, 'wb') as f:
                f.write(audio)
            logger.info(f"Archivo de audio generado: {audio_file}")
            return audio_file
        except Exception as e:
            logger.error(f"Error al generar audio con ElevenLabs: {e}")
            return None

    async def generate_video_from_events(self, audio_file: str) -> str:
        """Genera un video a partir de los eventos del dÃ­a y el archivo de audio."""
        clips = []
        for e in self.events:
            # Crear un clip de texto para cada evento
            text_clip = TextClip(
                txt=e.get('summary', 'Sin resumen'),
                fontsize=40,
                color='white',
                bg_color='black',
                font='Arial',
                size=(1280, 720),
                method='caption',
                align='center',
                kerning=-2
            ).set_duration(5)  # DuraciÃ³n del clip
